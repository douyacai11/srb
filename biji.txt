0.环境搭建:
    mysql5.7不能加cj  也需要设置&useSSL=false
    driver-class-name: com.mysql.jdbc.Driver
       url: jdbc:mysql://47.108.222.62:3306/db2023_srb_core?serverTimezone=GMT%2B8&characterEncoding=utf-8&useSSL=false
       username: root
       password: 123456

1.定义统一返回结果:
   使用枚举类（用来定义枚举 需要+lombok的@AllArgsConstructor注解 + 实体类型结合 作为返回值:可以设置更详细的参数


2.controller中的业务逻辑:
   当方法的返回值是list/对象的时候  可以使用message(key,value)的方法返回改对象
   即:  IntegralGrade integralGrade = integralGradeService.getById(id);
             if (integralGrade!=null){
                 return R.ok().data("record",integralGrade);}



3.了解了Swagger2



4.学习使用异常处理
4.1普通异常处理:
1、添加依赖 spring-jdbc
2.添加异常处理普通方法  在 UnifiedExceptionHandler
  //普通异常处理
    @ExceptionHandler(value = Exception.class)
    public R handleException(Exception e){
        log.error(e.getMessage(),e);
        return R.error();
    }



4.2自定义异常处理:
1、添加依赖 spring-jdbc
2.添加异常处理方法  在 UnifiedExceptionHandler(统一处理所有异常的 中添加BusinessException方法
3.如果需要创建自定义异常 在BusinessException自定义 状态码 +错误消息+有参构造方法
eg: if (integralGrade.getBorrowAmount()==null){
               //通过自定义类型的异常类 抛出 借款额度不合法的枚举
               throw  new BusinessException(ResponseEnum.BORROW_AMOUNT_NULL_ERROR);
           }
           ->是先走UnifiedExceptionHandler方法查找 BusinessException方法 ，然后进入BusinessException方法
           然后参数是ResponseEnum.BORROW_AMOUNT_NULL_ERROR ，即进入方法的枚举有参构造，返回自定义的错误消息




5.Excel文件导入到数据库:
p164-165

5.1先前端上传要读取的excel文件 前端发起请求给controller (前端调用后端的import接口

5.2controller 编写接口 file获取inputstream 传递给service

 InputStream inputStream = file.getInputStream();
            dictService.importData(inputStream);

5.3 service层执行的是监听器ExcelDictDTOListener的创建，来执行Excel的读功能，把获取的数据封装到ExcelDictDTO实体中,

  EasyExcel.read(inputStream, ExcelDictDTO.class, new ExcelDictDTOListener(baseMapper)).sheet().doRead();

   具体封装过程是在监听器内部实现的,只需要把监听器中封装好的data数据取出来 ，再调用mapper层的方法save至数据库中


5.4 save方法的实现: 如果数据过多 先存在一个集合中 指定存入数据到达x条 就存入list到数据库中


 @Resource
    DictService dictService;

    @ApiOperation("Excel数据的批量导入")
    @PostMapping("import")
    public R batchImport(
            @ApiParam(value = "Excel数据字典文件",required = true)
            @RequestParam("file")MultipartFile file)
    {
        try {
            InputStream inputStream = file.getInputStream();
            dictService.importData(inputStream);

            return R.ok().message("数据字典数据批量导入成功");

        } catch (Exception e) {
            throw new BusinessException(ResponseEnum.UPLOAD_ERROR,e);
        }
    }


    6.把一种类型转变为另外一种类型的方法: BeanUtils.copyProperties(要改变的类型,改变后的类型)

     public List<ExcelDictDTO> listDictData() {
            List<Dict> dictList = baseMapper.selectList(null);

            //把将Dict列表转换成ExcelDictDTO列表:先创建ExcelDictDTO列表

            ArrayList<ExcelDictDTO> excelDictDTOList = new ArrayList<>(dictList.size());
            dictList.forEach(dict -> {

                ExcelDictDTO excelDictDTO = new ExcelDictDTO();
                BeanUtils.copyProperties(dict, excelDictDTO);
                excelDictDTOList.add(excelDictDTO);
            });
            return excelDictDTOList;
            }


7.当列表中有父子 两层关系的时候 :定义接口 根据 parentId(父节点) 获取 父+子 节点列表

  7.1 在controller中定义接口方法  public R listByParentId(@PathVariable Long parentId){
       ----根据parentId获取子节点列表
            List<Dict> dictList= dictService.listByParentId(parentId);
                  return R.ok().data("dictList",dictList);
      }
  7.1 在service层中定义辅助方法  先判断父节点下面是否有子节点,再把当前节点下的所有数据取出 (顶层取顶层 / 顶层取二层
       -----根据父节点id来查询信息  即条件查询
         QueryWrapper<Dict> wrapper = new QueryWrapper<>();
              wrapper.eq("parent_id",parentId);
              List<Dict> dictList = baseMapper.selectList(wrapper);

              //填充hasChildren字段
              dictList.forEach(dict -> {
                  //判断当前节点是否有子节点,找到当前dict的下级有没有子节点
                  boolean hasChildren = this.hasChildren(dict.getId());
                  dict.setHasChildren(hasChildren);
              });
              return  dictList;


8.数据整合在redis中 适合于: 频繁访问的数据+数据不会经常更新的数据
   存入redis 的方法就是在impl业务层 增加redis的操作:

  /**
         * 1.先查询redis中是否存在数据列表
         *   redisTemplate.opsForValue().get("srb:core:dictList:" + parentId);
         * 2.1如果存在 则从redis中直接返回数据列表
         *     return dictList;
         * 2.2不存在 就查询数据库 将数据存入redis 再返回数据列表

         * */


9.发短信的逻辑
  1.先校验手机号是否为空 再校验手机号的合法性
  2.给用户发送验证码的同时 需要同时存入验证码到redis中


10.前后端相连接的逻辑：
   1.写好后端的接口 即controller定义的路径及其方法内容 eg：发短信
   2.前端: 点击‘发送验证码’ 即 发送aj克斯请求: 即 访问后端定义好的接口链接，then后面的是发送链接返回给前端的内容
                                this.$axios
                                      .$get('http://localhost:8120/api/sms/send/' + this.userInfo.mobile)
                                      .then((Response) => {
                                        this.$message.success(Response.message)
                                      })
                                  },

11.注册register用户的逻辑:
   填好了前端的表单,后端主要是用来收集表单的信息的,
   然后先  -- 发送短信 --获取验证码  --后端校验验证码(手机号 密码，是否为空
      再  实现插入功能 （先在数据库中查询手机号是否注册过了   再 往数据库中插入信息


12.登录login的逻辑实现:  生成token令牌,即要创建一个新的实体,要有token属性来保存
       //0.拿到前端输入的表单信息
        //1.查询手机号是否存在, 存在就查询数据库中的userInfo信息
         //2.1校验数据库中存入的密码和 前端输入的密码 是否正确
          //3.生成token
           //4.组装一个新的实体userInfoVo，返回前端


13.多条件查询+分页page条件 来展示用户列表的功能
       1.首先有三个查询条件,手机号+状态+userType，所以把这三个属性封装在一个新的对象 UserInfoQuery实体中
       2. controller中编写接口 ，参数需要 分页条件(limit，page  + 查询条件(封装好的UserInfoQuery实体
           :  public R listPage( @PathVariable  Long page,     @PathVariable Long limit , UserInfoQuery userInfoQuery

       3.service层中编写具体的查询方法:
            因为查询条件中有三个， 可以输入任意俩为空也能查的效果 所以需要QueryWrapper的重载 condition条件
           QueryWrapper<UserInfo> userInfoQueryWrapper = new QueryWrapper<>();
                   userInfoQueryWrapper.eq(StringUtils.isNotBlank(mobile),"mobile",mobile)
                                       .eq(status!=null,"status",status)
                                       .eq(userType!=null,"user_type",userType);






14.跨越问题是 @@GetMapping和前端的 method:post不对应 应该为get